"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.upload = void 0;
const http_1 = __importDefault(require("http"));
const https_1 = __importDefault(require("https"));
const stream_1 = require("stream");
const events_1 = require("events");
const async_retry_1 = __importDefault(require("async-retry"));
const async_sema_1 = require("async-sema");
const utils_1 = require("./utils");
const errors_1 = require("./errors");
const deploy_1 = require("./deploy");
const isClientNetworkError = (err) => {
    if (err.message) {
        // These are common network errors that may happen occasionally and we should retry if we encounter these
        return (err.message.includes('ETIMEDOUT') ||
            err.message.includes('ECONNREFUSED') ||
            err.message.includes('ENOTFOUND') ||
            err.message.includes('ECONNRESET') ||
            err.message.includes('EAI_FAIL') ||
            err.message.includes('socket hang up') ||
            err.message.includes('network socket disconnected'));
    }
    return false;
};
async function* upload(files, clientOptions, deploymentOptions) {
    const { token, teamId, apiUrl, userAgent } = clientOptions;
    const debug = (0, utils_1.createDebug)(clientOptions.debug);
    if (!files && !token && !teamId) {
        debug(`Neither 'files', 'token' nor 'teamId are present. Exiting`);
        return;
    }
    let shas = [];
    debug('Determining necessary files for upload...');
    for await (const event of (0, deploy_1.deploy)(files, clientOptions, deploymentOptions)) {
        if (event.type === 'error') {
            if (event.payload.code === 'missing_files') {
                shas = event.payload.missing;
                debug(`${shas.length} files are required to upload`);
            }
            else {
                return yield event;
            }
        }
        else {
            // If the deployment has succeeded here, don't continue
            if (event.type === 'alias-assigned') {
                debug('Deployment succeeded on file check');
                return yield event;
            }
            yield event;
        }
    }
    const uploads = shas.map(sha => {
        return new UploadProgress(sha, files.get(sha));
    });
    yield {
        type: 'file-count',
        payload: { total: files, missing: shas, uploads },
    };
    const uploadList = {};
    debug('Building an upload list...');
    const semaphore = new async_sema_1.Sema(50, { capacity: 50 });
    const defaultAgent = apiUrl?.startsWith('https://')
        ? new https_1.default.Agent({ keepAlive: true })
        : new http_1.default.Agent({ keepAlive: true });
    shas.forEach((sha, index) => {
        const uploadProgress = uploads[index];
        uploadList[sha] = (0, async_retry_1.default)(async (bail) => {
            const file = files.get(sha);
            if (!file) {
                debug(`File ${sha} is undefined. Bailing`);
                return bail(new Error(`File ${sha} is undefined`));
            }
            await semaphore.acquire();
            const { data } = file;
            if (typeof data === 'undefined') {
                // Directories don't need to be uploaded
                return;
            }
            uploadProgress.bytesUploaded = 0;
            // Split out into chunks
            const body = new stream_1.Readable();
            const originalRead = body.read.bind(body);
            body.read = function (...args) {
                const chunk = originalRead(...args);
                if (chunk) {
                    uploadProgress.bytesUploaded += chunk.length;
                    uploadProgress.emit('progress');
                }
                return chunk;
            };
            const chunkSize = 16384; /* 16kb - default Node.js `highWaterMark` */
            for (let i = 0; i < data.length; i += chunkSize) {
                const chunk = data.slice(i, i + chunkSize);
                body.push(chunk);
            }
            body.push(null);
            let err;
            let result;
            try {
                const res = await (0, utils_1.fetch)(utils_1.API_FILES, token, {
                    agent: clientOptions.agent || defaultAgent,
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/octet-stream',
                        'Content-Length': data.length,
                        'x-now-digest': sha,
                        'x-now-size': data.length,
                    },
                    body,
                    teamId,
                    apiUrl,
                    userAgent,
                }, clientOptions.debug, true);
                if (res.status === 200) {
                    debug(`File ${sha} (${file.names[0]}${file.names.length > 1 ? ` +${file.names.length}` : ''}) uploaded`);
                    result = {
                        type: 'file-uploaded',
                        payload: { sha, file },
                    };
                }
                else if (res.status > 200 && res.status < 500) {
                    // If something is wrong with our request, we don't retry
                    debug(`An internal error occurred in upload request. Not retrying...`);
                    const { error } = await res.json();
                    err = new errors_1.DeploymentError(error);
                }
                else {
                    // If something is wrong with the server, we retry
                    debug(`A server error occurred in upload request. Retrying...`);
                    const { error } = await res.json();
                    throw new errors_1.DeploymentError(error);
                }
            }
            catch (e) {
                debug(`An unexpected error occurred in upload promise:\n${e}`);
                err = new Error(e);
            }
            semaphore.release();
            if (err) {
                if (isClientNetworkError(err)) {
                    debug('Network error, retrying: ' + err.message);
                    // If it's a network error, we retry
                    throw err;
                }
                else {
                    debug('Other error, bailing: ' + err.message);
                    // Otherwise we bail
                    return bail(err);
                }
            }
            return result;
        }, {
            retries: 5,
            factor: 6,
            minTimeout: 10,
        });
    });
    debug('Starting upload');
    while (Object.keys(uploadList).length > 0) {
        try {
            const event = await Promise.race(Object.keys(uploadList).map((key) => uploadList[key]));
            delete uploadList[event.payload.sha];
            yield event;
        }
        catch (e) {
            return yield { type: 'error', payload: e };
        }
    }
    debug('All files uploaded');
    yield { type: 'all-files-uploaded', payload: files };
    try {
        debug('Starting deployment creation');
        for await (const event of (0, deploy_1.deploy)(files, clientOptions, deploymentOptions)) {
            if (event.type === 'alias-assigned') {
                debug('Deployment is ready');
                return yield event;
            }
            yield event;
        }
    }
    catch (e) {
        debug('An unexpected error occurred when starting deployment creation');
        yield { type: 'error', payload: e };
    }
}
exports.upload = upload;
class UploadProgress extends events_1.EventEmitter {
    constructor(sha, file) {
        super();
        this.sha = sha;
        this.file = file;
        this.bytesUploaded = 0;
    }
}
