"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDebug = exports.prepareFiles = exports.fetch = exports.getVercelIgnore = exports.buildFileTree = exports.parseVercelConfig = exports.getApiDeploymentsUrl = exports.EVENTS = exports.API_FILES = void 0;
const fetch_1 = require("./fetch");
const path_1 = require("path");
const url_1 = require("url");
const ignore_1 = __importDefault(require("ignore"));
const pkg_1 = require("../pkg");
const build_utils_1 = require("@vercel/build-utils");
const async_sema_1 = require("async-sema");
const fs_extra_1 = require("fs-extra");
const readdir_recursive_1 = __importDefault(require("./readdir-recursive"));
const semaphore = new async_sema_1.Sema(10);
exports.API_FILES = '/v2/files';
const EVENTS_ARRAY = [
    // File events
    'hashes-calculated',
    'file-count',
    'file-uploaded',
    'all-files-uploaded',
    // Deployment events
    'created',
    'building',
    'ready',
    'alias-assigned',
    'warning',
    'error',
    'notice',
    'tip',
    'canceled',
    // Checks events
    'checks-registered',
    'checks-completed',
    'checks-running',
    'checks-conclusion-succeeded',
    'checks-conclusion-failed',
    'checks-conclusion-skipped',
    'checks-conclusion-canceled',
];
exports.EVENTS = new Set(EVENTS_ARRAY);
function getApiDeploymentsUrl(metadata) {
    if (metadata && metadata.builds && !metadata.functions) {
        return '/v10/deployments';
    }
    return '/v13/deployments';
}
exports.getApiDeploymentsUrl = getApiDeploymentsUrl;
async function parseVercelConfig(filePath) {
    if (!filePath) {
        return {};
    }
    try {
        const jsonString = await (0, fs_extra_1.readFile)(filePath, 'utf8');
        return JSON.parse(jsonString);
    }
    catch (e) {
        // eslint-disable-next-line no-console
        console.error(e);
        return {};
    }
}
exports.parseVercelConfig = parseVercelConfig;
const maybeRead = async function (path, default_) {
    try {
        return await (0, fs_extra_1.readFile)(path, 'utf8');
    }
    catch (err) {
        return default_;
    }
};
async function buildFileTree(path, { isDirectory, prebuilt, }, debug) {
    const ignoreList = [];
    let fileList;
    let { ig, ignores } = await getVercelIgnore(path, prebuilt);
    debug(`Found ${ignores.length} rules in .vercelignore`);
    debug('Building file tree...');
    if (isDirectory && !Array.isArray(path)) {
        // Directory path
        const ignores = (absPath) => {
            const rel = (0, path_1.relative)(path, absPath);
            const ignored = ig.ignores(rel);
            if (ignored) {
                ignoreList.push(rel);
            }
            return ignored;
        };
        fileList = await (0, readdir_recursive_1.default)(path, [ignores]);
        debug(`Found ${fileList.length} files in the specified directory`);
    }
    else if (Array.isArray(path)) {
        // Array of file paths
        fileList = path;
        debug(`Assigned ${fileList.length} files provided explicitly`);
    }
    else {
        // Single file
        fileList = [path];
        debug(`Deploying the provided path as single file`);
    }
    return { fileList, ignoreList };
}
exports.buildFileTree = buildFileTree;
async function getVercelIgnore(cwd, prebuilt) {
    const ig = (0, ignore_1.default)();
    let ignores;
    if (prebuilt) {
        const outputDir = '.vercel/output';
        ignores = ['*'];
        const parts = outputDir.split('/');
        parts.forEach((_, i) => {
            const level = parts.slice(0, i + 1).join('/');
            ignores.push(`!${level}`);
        });
        ignores.push(`!${outputDir}/**`);
        ig.add(ignores.join('\n'));
    }
    else {
        ignores = [
            '.hg',
            '.git',
            '.gitmodules',
            '.svn',
            '.cache',
            '.next',
            '.now',
            '.vercel',
            '.npmignore',
            '.dockerignore',
            '.gitignore',
            '.*.swp',
            '.DS_Store',
            '.wafpicke-*',
            '.lock-wscript',
            '.env.local',
            '.env.*.local',
            '.venv',
            'npm-debug.log',
            'config.gypi',
            'node_modules',
            '__pycache__',
            'venv',
            'CVS',
        ];
        const cwds = Array.isArray(cwd) ? cwd : [cwd];
        const files = await Promise.all(cwds.map(async (cwd) => {
            const [vercelignore, nowignore] = await Promise.all([
                maybeRead((0, path_1.join)(cwd, '.vercelignore'), ''),
                maybeRead((0, path_1.join)(cwd, '.nowignore'), ''),
            ]);
            if (vercelignore && nowignore) {
                throw new build_utils_1.NowBuildError({
                    code: 'CONFLICTING_IGNORE_FILES',
                    message: 'Cannot use both a `.vercelignore` and `.nowignore` file. Please delete the `.nowignore` file.',
                    link: 'https://vercel.link/combining-old-and-new-config',
                });
            }
            return vercelignore || nowignore;
        }));
        const ignoreFile = files.join('\n');
        ig.add(`${ignores.join('\n')}\n${clearRelative(ignoreFile)}`);
    }
    return { ig, ignores };
}
exports.getVercelIgnore = getVercelIgnore;
/**
 * Remove leading `./` from the beginning of ignores
 * because ignore doesn't like them :|
 */
function clearRelative(str) {
    return str.replace(/(\n|^)\.\//g, '$1');
}
const fetch = async (url, token, opts = {}, debugEnabled, useNodeFetch) => {
    semaphore.acquire();
    const debug = createDebug(debugEnabled);
    let time;
    url = `${opts.apiUrl || 'https://api.vercel.com'}${url}`;
    delete opts.apiUrl;
    if (opts.teamId) {
        const parsedUrl = new url_1.URL(url);
        parsedUrl.searchParams.set('teamId', opts.teamId);
        url = parsedUrl.toString();
        delete opts.teamId;
    }
    const userAgent = opts.userAgent || `client-v${pkg_1.pkgVersion}`;
    delete opts.userAgent;
    opts.headers = {
        ...opts.headers,
        authorization: `Bearer ${token}`,
        accept: 'application/json',
        'user-agent': userAgent,
    };
    debug(`${opts.method || 'GET'} ${url}`);
    time = Date.now();
    const res = useNodeFetch
        ? await (0, fetch_1.nodeFetch)(url, opts)
        : await (0, fetch_1.zeitFetch)(url, opts);
    debug(`DONE in ${Date.now() - time}ms: ${opts.method || 'GET'} ${url}`);
    semaphore.release();
    return res;
};
exports.fetch = fetch;
const isWin = process.platform.includes('win');
const prepareFiles = (files, clientOptions) => {
    const preparedFiles = [];
    for (const [sha, file] of files) {
        for (const name of file.names) {
            let fileName;
            if (clientOptions.isDirectory) {
                // Directory
                fileName =
                    typeof clientOptions.path === 'string'
                        ? (0, path_1.relative)(clientOptions.path, name)
                        : name;
            }
            else {
                // Array of files or single file
                const segments = name.split(path_1.sep);
                fileName = segments[segments.length - 1];
            }
            preparedFiles.push({
                file: isWin ? fileName.replace(/\\/g, '/') : fileName,
                size: file.data?.byteLength || file.data?.length,
                mode: file.mode,
                sha: sha || undefined,
            });
        }
    }
    return preparedFiles;
};
exports.prepareFiles = prepareFiles;
function createDebug(debug) {
    if (debug) {
        return (...logs) => {
            process.stderr.write([`[client-debug] ${new Date().toISOString()}`, ...logs].join(' ') + '\n');
        };
    }
    return () => { };
}
exports.createDebug = createDebug;
