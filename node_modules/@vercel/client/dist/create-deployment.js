"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = require("fs-extra");
const path_1 = require("path");
const hashes_1 = require("./utils/hashes");
const upload_1 = require("./upload");
const utils_1 = require("./utils");
const errors_1 = require("./errors");
const build_utils_1 = require("@vercel/build-utils");
const tar_fs_1 = __importDefault(require("tar-fs"));
const zlib_1 = require("zlib");
function buildCreateDeployment() {
    return async function* createDeployment(clientOptions, deploymentOptions = {}) {
        const { path } = clientOptions;
        const debug = (0, utils_1.createDebug)(clientOptions.debug);
        debug('Creating deployment...');
        if (typeof path !== 'string' && !Array.isArray(path)) {
            debug(`Error: 'path' is expected to be a string or an array. Received ${typeof path}`);
            throw new errors_1.DeploymentError({
                code: 'missing_path',
                message: 'Path not provided',
            });
        }
        if (typeof clientOptions.token !== 'string') {
            debug(`Error: 'token' is expected to be a string. Received ${typeof clientOptions.token}`);
            throw new errors_1.DeploymentError({
                code: 'token_not_provided',
                message: 'Options object must include a `token`',
            });
        }
        clientOptions.isDirectory =
            !Array.isArray(path) && (0, fs_extra_1.lstatSync)(path).isDirectory();
        if (Array.isArray(path)) {
            for (const filePath of path) {
                if (!(0, path_1.isAbsolute)(filePath)) {
                    throw new errors_1.DeploymentError({
                        code: 'invalid_path',
                        message: `Provided path ${filePath} is not absolute`,
                    });
                }
            }
        }
        else if (!(0, path_1.isAbsolute)(path)) {
            throw new errors_1.DeploymentError({
                code: 'invalid_path',
                message: `Provided path ${path} is not absolute`,
            });
        }
        if (clientOptions.isDirectory && !Array.isArray(path)) {
            debug(`Provided 'path' is a directory.`);
        }
        else if (Array.isArray(path)) {
            debug(`Provided 'path' is an array of file paths`);
        }
        else {
            debug(`Provided 'path' is a single file`);
        }
        const { fileList } = await (0, utils_1.buildFileTree)(path, clientOptions, debug);
        // This is a useful warning because it prevents people
        // from getting confused about a deployment that renders 404.
        if (fileList.length === 0) {
            debug('Deployment path has no files. Yielding a warning event');
            yield {
                type: 'warning',
                payload: 'There are no files inside your deployment.',
            };
        }
        // Populate Files -> FileFsRef mapping
        const workPath = typeof path === 'string' ? path : path[0];
        let files;
        if (clientOptions.archive === 'tgz') {
            debug('Packing tarball');
            const tarStream = tar_fs_1.default
                .pack(workPath, {
                entries: fileList.map(file => (0, path_1.relative)(workPath, file)),
            })
                .pipe((0, zlib_1.createGzip)());
            const tarBuffer = await (0, build_utils_1.streamToBuffer)(tarStream);
            debug('Packed tarball');
            files = new Map([
                [
                    (0, hashes_1.hash)(tarBuffer),
                    {
                        names: [(0, path_1.join)(workPath, '.vercel/source.tgz')],
                        data: tarBuffer,
                        mode: 0o666,
                    },
                ],
            ]);
        }
        else {
            files = await (0, hashes_1.hashes)(fileList);
        }
        debug(`Yielding a 'hashes-calculated' event with ${files.size} hashes`);
        yield { type: 'hashes-calculated', payload: (0, hashes_1.mapToObject)(files) };
        if (clientOptions.apiUrl) {
            debug(`Using provided API URL: ${clientOptions.apiUrl}`);
        }
        if (clientOptions.userAgent) {
            debug(`Using provided user agent: ${clientOptions.userAgent}`);
        }
        debug(`Setting platform version to harcoded value 2`);
        deploymentOptions.version = 2;
        debug(`Creating the deployment and starting upload...`);
        for await (const event of (0, upload_1.upload)(files, clientOptions, deploymentOptions)) {
            debug(`Yielding a '${event.type}' event`);
            yield event;
        }
    };
}
exports.default = buildCreateDeployment;
