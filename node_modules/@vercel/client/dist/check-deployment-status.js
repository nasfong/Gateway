"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkDeploymentStatus = void 0;
const sleep_promise_1 = __importDefault(require("sleep-promise"));
const utils_1 = require("./utils");
const get_polling_delay_1 = require("./utils/get-polling-delay");
const ready_state_1 = require("./utils/ready-state");
const utils_2 = require("./utils");
/* eslint-disable */
async function* checkDeploymentStatus(deployment, clientOptions) {
    const { token, teamId, apiUrl, userAgent } = clientOptions;
    const debug = (0, utils_2.createDebug)(clientOptions.debug);
    let deploymentState = deployment;
    const apiDeployments = (0, utils_1.getApiDeploymentsUrl)({
        builds: deployment.builds,
        functions: deployment.functions,
    });
    // If the deployment is ready, we don't want any of this to run
    if ((0, ready_state_1.isDone)(deploymentState) && (0, ready_state_1.isAliasAssigned)(deploymentState)) {
        debug(`Deployment is already READY and aliases are assigned. Not running status checks`);
        return;
    }
    // Build polling
    debug('Waiting for builds and the deployment to complete...');
    const finishedEvents = new Set();
    const startTime = Date.now();
    while (true) {
        // Deployment polling
        const deploymentData = await (0, utils_1.fetch)(`${apiDeployments}/${deployment.id || deployment.deploymentId}${teamId ? `?teamId=${teamId}` : ''}`, token, { apiUrl, userAgent, agent: clientOptions.agent });
        const deploymentUpdate = await deploymentData.json();
        if (deploymentUpdate.error) {
            debug('Deployment status check has errorred');
            return yield { type: 'error', payload: deploymentUpdate.error };
        }
        if (deploymentUpdate.readyState === 'BUILDING' &&
            !finishedEvents.has('building')) {
            debug('Deployment state changed to BUILDING');
            finishedEvents.add('building');
            yield { type: 'building', payload: deploymentUpdate };
        }
        if (deploymentUpdate.readyState === 'CANCELED' &&
            !finishedEvents.has('canceled')) {
            debug('Deployment state changed to CANCELED');
            finishedEvents.add('canceled');
            yield { type: 'canceled', payload: deploymentUpdate };
        }
        if ((0, ready_state_1.isReady)(deploymentUpdate) && !finishedEvents.has('ready')) {
            debug('Deployment state changed to READY');
            finishedEvents.add('ready');
            yield { type: 'ready', payload: deploymentUpdate };
        }
        if (deploymentUpdate.checksState !== undefined) {
            if (deploymentUpdate.checksState === 'completed' &&
                !finishedEvents.has('checks-completed')) {
                finishedEvents.add('checks-completed');
                if (deploymentUpdate.checksConclusion === 'succeeded') {
                    yield {
                        type: 'checks-conclusion-succeeded',
                        payload: deploymentUpdate,
                    };
                }
                else if (deploymentUpdate.checksConclusion === 'failed') {
                    yield { type: 'checks-conclusion-failed', payload: deploymentUpdate };
                }
                else if (deploymentUpdate.checksConclusion === 'skipped') {
                    yield {
                        type: 'checks-conclusion-skipped',
                        payload: deploymentUpdate,
                    };
                }
                else if (deploymentUpdate.checksConclusion === 'canceled') {
                    yield {
                        type: 'checks-conclusion-canceled',
                        payload: deploymentUpdate,
                    };
                }
            }
            if (deploymentUpdate.checksState === 'registered' &&
                !finishedEvents.has('checks-registered')) {
                finishedEvents.add('checks-registered');
                yield { type: 'checks-registered', payload: deploymentUpdate };
            }
            if (deploymentUpdate.checksState === 'running' &&
                !finishedEvents.has('checks-running')) {
                finishedEvents.add('checks-running');
                yield { type: 'checks-running', payload: deploymentUpdate };
            }
        }
        if ((0, ready_state_1.isAliasAssigned)(deploymentUpdate)) {
            debug('Deployment alias assigned');
            return yield { type: 'alias-assigned', payload: deploymentUpdate };
        }
        if ((0, ready_state_1.isAliasError)(deploymentUpdate)) {
            return yield { type: 'error', payload: deploymentUpdate.aliasError };
        }
        if (deploymentUpdate.readyState === 'ERROR' &&
            deploymentUpdate.errorCode === 'BUILD_FAILED') {
            return yield { type: 'error', payload: deploymentUpdate };
        }
        if ((0, ready_state_1.isFailed)(deploymentUpdate)) {
            return yield {
                type: 'error',
                payload: deploymentUpdate.error || deploymentUpdate,
            };
        }
        const elapsed = Date.now() - startTime;
        const duration = (0, get_polling_delay_1.getPollingDelay)(elapsed);
        await (0, sleep_promise_1.default)(duration);
    }
}
exports.checkDeploymentStatus = checkDeploymentStatus;
